So: you don't have to like these rules, or adopt them yourselves, but you must follow them for this project.
Each company you work for in the future, if it is of a reasonable size, is likely to have it's own particular coding style, these are just my preferences, which is largely based on the assumption (a true assumption I believe) that you read code far more than you will ever write it. Code understanding, clarity and reading is therefore placed above concerns such as typing speed - which is largely irrelevant anyway in most modern IDE's which implement adequate code completion at the moment.


Basic rules:
============

A. This library is designed to be compatible with C++03 compilers and upwards, so no C++11 features are permitted. That means no auto, no rvalue references, and certainly no smart pointers. The exception is the plf::colony and plf::stack classes, but they are covered in very deep ways in both standards. Don't replicate that.


B. We're not using exceptions for this library - again, asides from plf::stack and plf::colony. This was a decision made early in development, in order to simplify library use, and also to make it more palatable for members of the SDL forums, who're more used to C-style return-and-check error testing. I don't have any particular problem with exceptions - for the most part.


C. Indent style is Allman or 'bsd'. I find this easier to parse in terms of matching up in-out brackets with code. Separate-line brackets are the only brackets permitted:
if (something)
{
   stuff
}

not

if (something) {
   stuff
}

nor

if (something) stuff;

The latter case inevitably leads to having to restructure when you add more stuff to the if block later, or add else clauses, and it's slower to parse visually.


D. Verbose names (classes, functions, variables, everything). With the appropriate context-sensitive pattern-matching IDE, typing these doesn't take any longer than short ones, and they are far quicker to parse visually. Be concise as possible without leaving anything vague. In the best case you won't need to provide comments as to what these variables/functions/etc mean or are. That is the point. Verbose code is self-documenting to the largest extent possible.
Exceptions: 'num_somethings' is fine, as something to indicate 'number_of_somethings'. This is fairly universal, as is 'something_num', to indicate the number assigned to a specific 'something'.
I think 'it' for iterator is also fairly universal, but please indicate what it is an iterator of eg. entity_it.
max and min for maximum and minimum also fine, and in the context of a rectangle where x & y are present, w & h for width and height also fine. Outside of the context of a rectangle, please use width and height instead.
You will lose soo many brownie points for using variable names like 'n', 'i' and 'k'. What does 'n' mean? Is it a meaningless counter? If so, call it 'counter'. If it's a counter for something specific, include that in the name.


E. under_scores, not camelCoding or similar. Easier to parse visually and easier/about the same to type.


F. Line separation: I dont have hard and fast rules, but I try to aim for 3 blank lines between functions, more if it's between sections of code that need some extra differentiation. Generally I have a single blank line between something large in a function like an if-block and regular code, or two lines if it needs further differentiation. This all aids searching code and reading.


G. Indentation: don't indent for namespaces, but do for classes (don't further indent the public: and private: indicators).


H. Hard tabs only, no spaces for indentation.


I. Const where possible - gives very clear guidelines as to where data is being transformed in code. Also minor performance boosts in some cases. Richard Powell's "The importance of being const" talk is good.


J. American spelling where there's a difference - no real preference, but it just makes things simpler to settle on a singular spelling of 'colour' vs 'color' etc. I haven't always been consistent with this in my commenting.


K. Codelite has workspaces, MSVC has 'Solution's, they're the same, both allow multiple projects ie. multiple .exe's/.dll's to compile, within them. This can be useful when needing to build multiple projects at once. We'll call them workspaces as a genericised term. What I find useful is to keep code separate from a workspace/solution/project folder, as this leads to fewer problems when having to share code between workspaces and compile across platforms eg. MSVC vs Codelite/gcc. So my programming subfolders might look something like this:

programming
|__
|  code
|  |__
|     plf_engine
|              |__
|                 plf_engine.h etc
|__
   workspaces
   |__
      plf_engine_gcc
   |__
      plf_engine_msvc

And then you just add the files from the code subfolder into your project, and add the location of the files to your project's 'include' folder list. That way there's no need to put #include "../../code/plf_engine/plf_engine.h".
Otherwise, you end up copying stuff around and generally making a mess/ making changes to one copy but not the other copy.
Make sure you use relative addressing in your project's 'include' folder list rather than absolute addresses (ie. "../../code/engine/" instead of "d:/programming/code/engine") - otherwise you'll end up having to create different workspaces for linux and windows.


L. When in doubt, look at existing code and take your lead from that.
